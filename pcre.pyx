#cython: embedsignature=True, infer_types=True, profile=True

cimport cpcre, cython
from libc.stdlib cimport malloc
from libc.string cimport const_char

# Public options. Some are compile-time only, some are run-time only, and some
# are both, so we keep them all distinct. However, almost all the bits in the
# options word are now used. In the long run, we may have to re-use some of the
# compile-time only bits for runtime options, or vice versa. Any of the
# compile-time options may be inspected during studying (and therefore JIT
# compiling).

# Some options for pcre_compile() change its behaviour but do not affect the
# behaviour of the execution functions. Other options are passed through to the
# execution functions and affect their behaviour, with or without affecting the
# behaviour of pcre_compile().

# Options that can be passed to pcre_compile() are tagged Cx below, with these
# variants:

# C1   Affects compile only
# C2   Does not affect compile; affects exec, dfa_exec
# C3   Affects compile, exec, dfa_exec
# C4   Affects compile, exec, dfa_exec, study
# C5   Affects compile, exec, study

# Options that can be set for pcre_exec() and/or pcre_dfa_exec() are flagged with
# E and D, respectively. They take precedence over C3, C4, and C5 settings passed
# from pcre_compile(). Those that are compatible with JIT execution are flagged
# with J.

### copied from _globals.py (generated by generate_globals.py)
PCRE_CASELESS = cpcre._PCRE_CASELESS                           #  C1       
PCRE_MULTILINE = cpcre._PCRE_MULTILINE                         #  C1       
PCRE_DOTALL = cpcre._PCRE_DOTALL                               #  C1       
PCRE_EXTENDED = cpcre._PCRE_EXTENDED                           #  C1       
PCRE_ANCHORED = cpcre._PCRE_ANCHORED                           #  C4 E D   
PCRE_DOLLAR_ENDONLY = cpcre._PCRE_DOLLAR_ENDONLY               #  C2       
PCRE_EXTRA = cpcre._PCRE_EXTRA                                 #  C1       
PCRE_NOTBOL = cpcre._PCRE_NOTBOL                               #     E D J 
PCRE_NOTEOL = cpcre._PCRE_NOTEOL                               #     E D J 
PCRE_UNGREEDY = cpcre._PCRE_UNGREEDY                           #  C1       
PCRE_NOTEMPTY = cpcre._PCRE_NOTEMPTY                           #     E D J 
PCRE_UTF8 = cpcre._PCRE_UTF8                                   #  C4        )          
PCRE_UTF16 = cpcre._PCRE_UTF16                                 #  C4        ) Synonyms 
PCRE_UTF32 = cpcre._PCRE_UTF32                                 #  C4        )          
PCRE_NO_AUTO_CAPTURE = cpcre._PCRE_NO_AUTO_CAPTURE             #  C1       
PCRE_NO_UTF8_CHECK = cpcre._PCRE_NO_UTF8_CHECK                 #  C1 E D J  )          
PCRE_NO_UTF16_CHECK = cpcre._PCRE_NO_UTF16_CHECK               #  C1 E D J  ) Synonyms 
PCRE_NO_UTF32_CHECK = cpcre._PCRE_NO_UTF32_CHECK               #  C1 E D J  )          
PCRE_AUTO_CALLOUT = cpcre._PCRE_AUTO_CALLOUT                   #  C1       
PCRE_PARTIAL_SOFT = cpcre._PCRE_PARTIAL_SOFT                   #     E D J  ) Synonyms 
PCRE_PARTIAL = cpcre._PCRE_PARTIAL                             #     E D J  )          
PCRE_DFA_SHORTEST = cpcre._PCRE_DFA_SHORTEST                   #       D   
PCRE_DFA_RESTART = cpcre._PCRE_DFA_RESTART                     #       D   
PCRE_FIRSTLINE = cpcre._PCRE_FIRSTLINE                         #  C3       
PCRE_DUPNAMES = cpcre._PCRE_DUPNAMES                           #  C1       
PCRE_NEWLINE_CR = cpcre._PCRE_NEWLINE_CR                       #  C3 E D   
PCRE_NEWLINE_LF = cpcre._PCRE_NEWLINE_LF                       #  C3 E D   
PCRE_NEWLINE_CRLF = cpcre._PCRE_NEWLINE_CRLF                   #  C3 E D   
PCRE_NEWLINE_ANY = cpcre._PCRE_NEWLINE_ANY                     #  C3 E D   
PCRE_NEWLINE_ANYCRLF = cpcre._PCRE_NEWLINE_ANYCRLF             #  C3 E D   
PCRE_BSR_ANYCRLF = cpcre._PCRE_BSR_ANYCRLF                     #  C3 E D   
PCRE_BSR_UNICODE = cpcre._PCRE_BSR_UNICODE                     #  C3 E D   
PCRE_JAVASCRIPT_COMPAT = cpcre._PCRE_JAVASCRIPT_COMPAT         #  C5       
PCRE_NO_START_OPTIMIZE = cpcre._PCRE_NO_START_OPTIMIZE         #  C2 E D    ) Synonyms 
PCRE_NO_START_OPTIMISE = cpcre._PCRE_NO_START_OPTIMISE         #  C2 E D    )          
PCRE_PARTIAL_HARD = cpcre._PCRE_PARTIAL_HARD                   #     E D J 
PCRE_NOTEMPTY_ATSTART = cpcre._PCRE_NOTEMPTY_ATSTART           #     E D J 
PCRE_UCP = cpcre._PCRE_UCP                                     #  C3       
PCRE_ERROR_NOMATCH = cpcre._PCRE_ERROR_NOMATCH
PCRE_ERROR_NULL = cpcre._PCRE_ERROR_NULL
PCRE_ERROR_BADOPTION = cpcre._PCRE_ERROR_BADOPTION
PCRE_ERROR_BADMAGIC = cpcre._PCRE_ERROR_BADMAGIC
PCRE_ERROR_UNKNOWN_OPCODE = cpcre._PCRE_ERROR_UNKNOWN_OPCODE
PCRE_ERROR_UNKNOWN_NODE = cpcre._PCRE_ERROR_UNKNOWN_NODE       #  For backward compatibility 
PCRE_ERROR_NOMEMORY = cpcre._PCRE_ERROR_NOMEMORY
PCRE_ERROR_NOSUBSTRING = cpcre._PCRE_ERROR_NOSUBSTRING
PCRE_ERROR_MATCHLIMIT = cpcre._PCRE_ERROR_MATCHLIMIT
PCRE_ERROR_CALLOUT = cpcre._PCRE_ERROR_CALLOUT                 #  Never used by PCRE itself 
PCRE_ERROR_BADUTF8 = cpcre._PCRE_ERROR_BADUTF8                 #  Same for 8/16/32 
PCRE_ERROR_BADUTF16 = cpcre._PCRE_ERROR_BADUTF16               #  Same for 8/16/32 
PCRE_ERROR_BADUTF32 = cpcre._PCRE_ERROR_BADUTF32               #  Same for 8/16/32 
PCRE_ERROR_BADUTF8_OFFSET = cpcre._PCRE_ERROR_BADUTF8_OFFSET   #  Same for 8/16 
PCRE_ERROR_BADUTF16_OFFSET = cpcre._PCRE_ERROR_BADUTF16_OFFSET #  Same for 8/16 
PCRE_ERROR_PARTIAL = cpcre._PCRE_ERROR_PARTIAL
PCRE_ERROR_BADPARTIAL = cpcre._PCRE_ERROR_BADPARTIAL
PCRE_ERROR_INTERNAL = cpcre._PCRE_ERROR_INTERNAL
PCRE_ERROR_BADCOUNT = cpcre._PCRE_ERROR_BADCOUNT
PCRE_ERROR_DFA_UITEM = cpcre._PCRE_ERROR_DFA_UITEM
PCRE_ERROR_DFA_UCOND = cpcre._PCRE_ERROR_DFA_UCOND
PCRE_ERROR_DFA_UMLIMIT = cpcre._PCRE_ERROR_DFA_UMLIMIT
PCRE_ERROR_DFA_WSSIZE = cpcre._PCRE_ERROR_DFA_WSSIZE
PCRE_ERROR_DFA_RECURSE = cpcre._PCRE_ERROR_DFA_RECURSE
PCRE_ERROR_RECURSIONLIMIT = cpcre._PCRE_ERROR_RECURSIONLIMIT
PCRE_ERROR_NULLWSLIMIT = cpcre._PCRE_ERROR_NULLWSLIMIT         #  No longer actually used 
PCRE_ERROR_BADNEWLINE = cpcre._PCRE_ERROR_BADNEWLINE
PCRE_ERROR_BADOFFSET = cpcre._PCRE_ERROR_BADOFFSET
PCRE_ERROR_SHORTUTF8 = cpcre._PCRE_ERROR_SHORTUTF8
PCRE_ERROR_SHORTUTF16 = cpcre._PCRE_ERROR_SHORTUTF16           #  Same for 8/16 
PCRE_ERROR_RECURSELOOP = cpcre._PCRE_ERROR_RECURSELOOP
PCRE_ERROR_JIT_STACKLIMIT = cpcre._PCRE_ERROR_JIT_STACKLIMIT
PCRE_ERROR_BADMODE = cpcre._PCRE_ERROR_BADMODE
PCRE_ERROR_BADENDIANNESS = cpcre._PCRE_ERROR_BADENDIANNESS
PCRE_ERROR_DFA_BADRESTART = cpcre._PCRE_ERROR_DFA_BADRESTART
PCRE_ERROR_JIT_BADOPTION = cpcre._PCRE_ERROR_JIT_BADOPTION
PCRE_ERROR_BADLENGTH = cpcre._PCRE_ERROR_BADLENGTH
PCRE_UTF8_ERR0 = cpcre._PCRE_UTF8_ERR0
PCRE_UTF8_ERR1 = cpcre._PCRE_UTF8_ERR1
PCRE_UTF8_ERR2 = cpcre._PCRE_UTF8_ERR2
PCRE_UTF8_ERR3 = cpcre._PCRE_UTF8_ERR3
PCRE_UTF8_ERR4 = cpcre._PCRE_UTF8_ERR4
PCRE_UTF8_ERR5 = cpcre._PCRE_UTF8_ERR5
PCRE_UTF8_ERR6 = cpcre._PCRE_UTF8_ERR6
PCRE_UTF8_ERR7 = cpcre._PCRE_UTF8_ERR7
PCRE_UTF8_ERR8 = cpcre._PCRE_UTF8_ERR8
PCRE_UTF8_ERR9 = cpcre._PCRE_UTF8_ERR9
PCRE_UTF8_ERR10 = cpcre._PCRE_UTF8_ERR10
PCRE_UTF8_ERR11 = cpcre._PCRE_UTF8_ERR11
PCRE_UTF8_ERR12 = cpcre._PCRE_UTF8_ERR12
PCRE_UTF8_ERR13 = cpcre._PCRE_UTF8_ERR13
PCRE_UTF8_ERR14 = cpcre._PCRE_UTF8_ERR14
PCRE_UTF8_ERR15 = cpcre._PCRE_UTF8_ERR15
PCRE_UTF8_ERR16 = cpcre._PCRE_UTF8_ERR16
PCRE_UTF8_ERR17 = cpcre._PCRE_UTF8_ERR17
PCRE_UTF8_ERR18 = cpcre._PCRE_UTF8_ERR18
PCRE_UTF8_ERR19 = cpcre._PCRE_UTF8_ERR19
PCRE_UTF8_ERR20 = cpcre._PCRE_UTF8_ERR20
PCRE_UTF8_ERR21 = cpcre._PCRE_UTF8_ERR21
PCRE_UTF8_ERR22 = cpcre._PCRE_UTF8_ERR22
PCRE_UTF16_ERR0 = cpcre._PCRE_UTF16_ERR0
PCRE_UTF16_ERR1 = cpcre._PCRE_UTF16_ERR1
PCRE_UTF16_ERR2 = cpcre._PCRE_UTF16_ERR2
PCRE_UTF16_ERR3 = cpcre._PCRE_UTF16_ERR3
PCRE_UTF16_ERR4 = cpcre._PCRE_UTF16_ERR4
PCRE_UTF32_ERR0 = cpcre._PCRE_UTF32_ERR0
PCRE_UTF32_ERR1 = cpcre._PCRE_UTF32_ERR1
PCRE_UTF32_ERR2 = cpcre._PCRE_UTF32_ERR2
PCRE_UTF32_ERR3 = cpcre._PCRE_UTF32_ERR3
PCRE_INFO_OPTIONS = cpcre._PCRE_INFO_OPTIONS
PCRE_INFO_SIZE = cpcre._PCRE_INFO_SIZE
PCRE_INFO_CAPTURECOUNT = cpcre._PCRE_INFO_CAPTURECOUNT
PCRE_INFO_BACKREFMAX = cpcre._PCRE_INFO_BACKREFMAX
PCRE_INFO_FIRSTBYTE = cpcre._PCRE_INFO_FIRSTBYTE
PCRE_INFO_FIRSTCHAR = cpcre._PCRE_INFO_FIRSTCHAR               #  For backwards compatibility 
PCRE_INFO_FIRSTTABLE = cpcre._PCRE_INFO_FIRSTTABLE
PCRE_INFO_LASTLITERAL = cpcre._PCRE_INFO_LASTLITERAL
PCRE_INFO_NAMEENTRYSIZE = cpcre._PCRE_INFO_NAMEENTRYSIZE
PCRE_INFO_NAMECOUNT = cpcre._PCRE_INFO_NAMECOUNT
PCRE_INFO_NAMETABLE = cpcre._PCRE_INFO_NAMETABLE
PCRE_INFO_STUDYSIZE = cpcre._PCRE_INFO_STUDYSIZE
PCRE_INFO_DEFAULT_TABLES = cpcre._PCRE_INFO_DEFAULT_TABLES
PCRE_INFO_OKPARTIAL = cpcre._PCRE_INFO_OKPARTIAL
PCRE_INFO_JCHANGED = cpcre._PCRE_INFO_JCHANGED
PCRE_INFO_HASCRORLF = cpcre._PCRE_INFO_HASCRORLF
PCRE_INFO_MINLENGTH = cpcre._PCRE_INFO_MINLENGTH
PCRE_INFO_JIT = cpcre._PCRE_INFO_JIT
PCRE_INFO_JITSIZE = cpcre._PCRE_INFO_JITSIZE
PCRE_INFO_MAXLOOKBEHIND = cpcre._PCRE_INFO_MAXLOOKBEHIND
PCRE_INFO_FIRSTCHARACTER = cpcre._PCRE_INFO_FIRSTCHARACTER
PCRE_INFO_FIRSTCHARACTERFLAGS = cpcre._PCRE_INFO_FIRSTCHARACTERFLAGS
PCRE_INFO_REQUIREDCHAR = cpcre._PCRE_INFO_REQUIREDCHAR
PCRE_INFO_REQUIREDCHARFLAGS = cpcre._PCRE_INFO_REQUIREDCHARFLAGS
PCRE_CONFIG_UTF8 = cpcre._PCRE_CONFIG_UTF8
PCRE_CONFIG_NEWLINE = cpcre._PCRE_CONFIG_NEWLINE
PCRE_CONFIG_LINK_SIZE = cpcre._PCRE_CONFIG_LINK_SIZE
PCRE_CONFIG_POSIX_MALLOC_THRESHOLD = cpcre._PCRE_CONFIG_POSIX_MALLOC_THRESHOLD
PCRE_CONFIG_MATCH_LIMIT = cpcre._PCRE_CONFIG_MATCH_LIMIT
PCRE_CONFIG_STACKRECURSE = cpcre._PCRE_CONFIG_STACKRECURSE
PCRE_CONFIG_UNICODE_PROPERTIES = cpcre._PCRE_CONFIG_UNICODE_PROPERTIES
PCRE_CONFIG_MATCH_LIMIT_RECURSION = cpcre._PCRE_CONFIG_MATCH_LIMIT_RECURSION
PCRE_CONFIG_BSR = cpcre._PCRE_CONFIG_BSR
PCRE_CONFIG_JIT = cpcre._PCRE_CONFIG_JIT
PCRE_CONFIG_UTF16 = cpcre._PCRE_CONFIG_UTF16
PCRE_CONFIG_JITTARGET = cpcre._PCRE_CONFIG_JITTARGET
PCRE_CONFIG_UTF32 = cpcre._PCRE_CONFIG_UTF32
PCRE_STUDY_JIT_COMPILE = cpcre._PCRE_STUDY_JIT_COMPILE
PCRE_STUDY_JIT_PARTIAL_SOFT_COMPILE = cpcre._PCRE_STUDY_JIT_PARTIAL_SOFT_COMPILE
PCRE_STUDY_JIT_PARTIAL_HARD_COMPILE = cpcre._PCRE_STUDY_JIT_PARTIAL_HARD_COMPILE
PCRE_STUDY_EXTRA_NEEDED = cpcre._PCRE_STUDY_EXTRA_NEEDED
PCRE_EXTRA_STUDY_DATA = cpcre._PCRE_EXTRA_STUDY_DATA
PCRE_EXTRA_MATCH_LIMIT = cpcre._PCRE_EXTRA_MATCH_LIMIT
PCRE_EXTRA_CALLOUT_DATA = cpcre._PCRE_EXTRA_CALLOUT_DATA
PCRE_EXTRA_TABLES = cpcre._PCRE_EXTRA_TABLES
PCRE_EXTRA_MATCH_LIMIT_RECURSION = cpcre._PCRE_EXTRA_MATCH_LIMIT_RECURSION
PCRE_EXTRA_MARK = cpcre._PCRE_EXTRA_MARK
PCRE_EXTRA_EXECUTABLE_JIT = cpcre._PCRE_EXTRA_EXECUTABLE_JIT

# compute some bit masks to avoid errors when supplying wrong options to some functions
cdef unsigned int PCRE_COMPILE_OPTIONS_MASK =\
        cpcre._PCRE_CASELESS |\
        cpcre._PCRE_MULTILINE |\
        cpcre._PCRE_DOTALL |\
        cpcre._PCRE_EXTENDED |\
        cpcre._PCRE_ANCHORED |\
        cpcre._PCRE_DOLLAR_ENDONLY |\
        cpcre._PCRE_EXTRA |\
        cpcre._PCRE_UNGREEDY |\
        cpcre._PCRE_UTF8 |\
        cpcre._PCRE_NO_AUTO_CAPTURE |\
        cpcre._PCRE_NO_UTF8_CHECK |\
        cpcre._PCRE_AUTO_CALLOUT |\
        cpcre._PCRE_FIRSTLINE |\
        cpcre._PCRE_DUPNAMES |\
        cpcre._PCRE_NEWLINE_CR |\
        cpcre._PCRE_NEWLINE_LF |\
        cpcre._PCRE_NEWLINE_CRLF |\
        cpcre._PCRE_NEWLINE_ANY |\
        cpcre._PCRE_NEWLINE_ANYCRLF |\
        cpcre._PCRE_BSR_ANYCRLF |\
        cpcre._PCRE_BSR_UNICODE |\
        cpcre._PCRE_JAVASCRIPT_COMPAT |\
        cpcre._PCRE_NO_START_OPTIMIZE |\
        cpcre._PCRE_UCP

cdef unsigned int PCRE_EXEC_OPTIONS_MASK =\
        cpcre._PCRE_ANCHORED |\
        cpcre._PCRE_NOTBOL |\
        cpcre._PCRE_NOTEOL |\
        cpcre._PCRE_NOTEMPTY |\
        cpcre._PCRE_NO_UTF8_CHECK |\
        cpcre._PCRE_PARTIAL_SOFT |\
        cpcre._PCRE_NEWLINE_CR |\
        cpcre._PCRE_NEWLINE_LF |\
        cpcre._PCRE_NEWLINE_CRLF |\
        cpcre._PCRE_NEWLINE_ANY |\
        cpcre._PCRE_NEWLINE_ANYCRLF |\
        cpcre._PCRE_BSR_ANYCRLF |\
        cpcre._PCRE_BSR_UNICODE |\
        cpcre._PCRE_NO_START_OPTIMIZE |\
        cpcre._PCRE_PARTIAL_HARD |\
        cpcre._PCRE_NOTEMPTY_ATSTART

cdef unsigned int PCRE_STUDY_OPTIONS_MASK =\
        cpcre._PCRE_STUDY_JIT_COMPILE |\
        cpcre._PCRE_STUDY_JIT_PARTIAL_SOFT_COMPILE |\
        cpcre._PCRE_STUDY_JIT_PARTIAL_HARD_COMPILE |\
        cpcre._PCRE_STUDY_EXTRA_NEEDED

cdef extern from "pyerrors.h":
    ctypedef class __builtin__.Exception [object PyBaseExceptionObject]:
        pass

cdef class PcreException(Exception):
    pass

cdef extern from "Python.h":
    object PyString_FromString(char *)
    object PyString_FromStringAndSize(char *s, Py_ssize_t len)

cdef class Pcre:
    cdef cpcre.pcre *_c_pcre
    cdef readonly:
        bint info_available
        int groups
        dict groupindex
    def __cinit__(self):
        self._c_pcre = NULL
        self.info_available = 0
        self.groups = 0
        self.groupindex = {}
    def __init__(self):
        raise TypeError("This class cannot be instantiated from Python")
    def __dealloc__(self):
        if self._c_pcre is not NULL:
            cpcre.pcre_free(self._c_pcre)

cdef class PcreExtra:
    cdef cpcre.pcre_extra *_c_pcre_extra
    def __cinit__(self):
        self._c_pcre_extra = NULL
    def __init__(self):
        raise TypeError("This class cannot be instantiated from Python")
    def __dealloc__(self):
        if self._c_pcre_extra is not NULL:
            cpcre.pcre_free_study(self._c_pcre_extra)
    property flags:
        def __get__(self):
            if self._c_pcre_extra is NULL:
                return 0
            return self._c_pcre_extra.flags
        def __set__(self, value):
            if self._c_pcre_extra is not NULL:
                self._c_pcre_extra.flags = value

cdef class ExecResult:
    cdef:
        int *ovector
        public unsigned char *markptr
    cdef readonly:
        int offset
        int result
        int num_matches
        bint captured_all
        list start_offsets
        list end_offsets
        list matches
        dict named_matches
        object lastindex
        object lastgroup
    def __cinit__(self):
        self.num_matches = 0
        self.captured_all = 1
        self.start_offsets = []
        self.end_offsets = []
        self.matches = []
        self.named_matches = {}
        self.ovector = NULL
        self.markptr = NULL
        self.lastindex = None
        self.lastgroup = None
    def __dealloc__(self):
        if self.ovector is not NULL:
            cpcre.pcre_free(self.ovector)
    property mark:
        def __get__(self):
            if self.markptr is NULL:
                return None
            return self.markptr

@cython.profile(False)
cdef inline process_text(text):
    if isinstance(text, unicode):
        text = text.encode('UTF-8')
    return text

@cython.profile(False)
cdef inline unicode tounicode(char* s):
    return s.decode('UTF-8', 'strict')

@cython.profile(False)
cdef inline unicode tounicode_with_length(char* s, size_t length):
    return s[:length].decode('UTF-8', 'strict')

ERROR_CODES = {
    cpcre._PCRE_ERROR_MATCHLIMIT: 'maximum match limit exceeded',
    cpcre._PCRE_ERROR_RECURSIONLIMIT: 'maximum recursion limit exceeded',
    cpcre._PCRE_ERROR_NULL: 'NULL parameter',
    cpcre._PCRE_ERROR_BADOPTION: 'unrecognized option (flag)',
    cpcre._PCRE_ERROR_BADMAGIC: 'magic number not present',
    cpcre._PCRE_ERROR_UNKNOWN_OPCODE: 'unknown opcode',
    cpcre._PCRE_ERROR_NOMEMORY: 'out of memory',
    cpcre._PCRE_ERROR_BADUTF8: 'invalid UTF-8 byte sequence',
    cpcre._PCRE_ERROR_BADUTF8_OFFSET: 'invalid UTF-8 offset',
    cpcre._PCRE_ERROR_INTERNAL: 'unexpected internal error',
    cpcre._PCRE_ERROR_BADCOUNT: 'invalid value for ovecsize',
    cpcre._PCRE_ERROR_BADNEWLINE: 'invalid combination of PCRE_NEWLINE_xxx options',
    cpcre._PCRE_ERROR_BADOFFSET: 'invalid offset',
    cpcre._PCRE_ERROR_SHORTUTF8: 'short UTF-8 byte sequence',
    cpcre._PCRE_ERROR_RECURSELOOP: 'recursion loop within the pattern',
    cpcre._PCRE_ERROR_JIT_STACKLIMIT: 'out of JIT memory',
    cpcre._PCRE_ERROR_BADMODE: 'a pattern that was compiled by the 8-bit library is passed to a 16-bit or 32-bit library function, or vice versa',
    cpcre._PCRE_ERROR_BADENDIANNESS: 'a pattern that was compiled and saved is reloaded on a host with different endianness',
    cpcre._PCRE_ERROR_JIT_BADOPTION: 'invalid option in JIT mode',
    cpcre._PCRE_ERROR_BADLENGTH: 'pcre_exec() was called with a negative value for the length argument',
}

@cython.profile(False)
cdef inline process_exec_error(int rc):
    if rc in ERROR_CODES:
        raise PcreException(ERROR_CODES[rc])

cpdef pcre_version():
    return cpcre.pcre_version()

cpdef inline Pcre pcre_compile(pattern, int options=0):
    cdef:
        const_char *error
        int erroffset
        cpcre.pcre *re
        Pcre pcre = Pcre.__new__(Pcre)

    if isinstance(pattern, unicode):
        options |= cpcre._PCRE_UTF8 | cpcre._PCRE_UCP
    pattern = process_text(pattern)
    re = cpcre.pcre_compile(pattern, options & PCRE_COMPILE_OPTIONS_MASK, &error, &erroffset, NULL)
    if re is NULL:
        raise PcreException('PCRE compilation failed at offset %d (%s)' % (erroffset, error))
    pcre._c_pcre = re
    return pcre

cpdef inline PcreExtra pcre_study(Pcre re, int options=0):
    cdef:
        cpcre.pcre_extra *sd
        PcreExtra pcre_extra = PcreExtra.__new__(PcreExtra)
        const_char *error

    sd = cpcre.pcre_study(re._c_pcre, (options | cpcre._PCRE_STUDY_EXTRA_NEEDED) & PCRE_STUDY_OPTIONS_MASK, &error)
    if error is not NULL:
        raise PcreException(error)
    pcre_extra._c_pcre_extra = sd
    return pcre_extra

cpdef PcreExtra pcre_create_empty_study():
    cdef:
        PcreExtra pcre_extra = PcreExtra.__new__(PcreExtra)
    pcre_extra._c_pcre_extra = <cpcre.pcre_extra *>malloc(sizeof(cpcre.pcre_extra))
    pcre_extra._c_pcre_extra.flags = 0
    return pcre_extra

cdef inline pcre_fullinfo_wrapper(cpcre.pcre* code, cpcre.pcre_extra* extra, int what, void* where):
    cdef int res = cpcre.pcre_fullinfo(code, extra, what, where)
    if res != 0:
        s = 'pcre_fullinfo() failed: %s'
        if res == cpcre._PCRE_ERROR_NULL:
            raise PcreException(s % 'NULL pointer')
        elif res == cpcre._PCRE_ERROR_BADMAGIC:
            raise PcreException(s % 'magic number not found in pattern')
        elif res == cpcre._PCRE_ERROR_BADENDIANNESS:
            raise PcreException(s % 'the pattern was compiled with different endianness')
        elif res == cpcre._PCRE_ERROR_BADOPTION:
            raise PcreException(s % 'invalid option number')
        else:
            raise PcreException(s % 'unknown')

cpdef inline pcre_info(Pcre re, PcreExtra extra=None):
    cdef:
        int capture_count
        int namecount
        char *name_table
        int name_entry_size
        char *tabptr
        int i, n

    re.info_available = 1

    # number of captures
    pcre_fullinfo_wrapper(re._c_pcre, extra._c_pcre_extra, cpcre._PCRE_INFO_CAPTURECOUNT, &capture_count)
    re.groups = capture_count
    
    # named substrings
    pcre_fullinfo_wrapper(re._c_pcre, extra._c_pcre_extra, cpcre._PCRE_INFO_NAMECOUNT, &namecount)
    if namecount > 0:
        pcre_fullinfo_wrapper(re._c_pcre, extra._c_pcre_extra, cpcre._PCRE_INFO_NAMETABLE, &name_table)
        pcre_fullinfo_wrapper(re._c_pcre, extra._c_pcre_extra, cpcre._PCRE_INFO_NAMEENTRYSIZE, &name_entry_size)
        tabptr = name_table
        for i in xrange(namecount):
            n = (tabptr[0] << 8) | tabptr[1]
            substring_name = PyString_FromString(tabptr + 2)
            re.groupindex[substring_name] = n
            tabptr += name_entry_size

cpdef inline ExecResult pcre_exec(Pcre re, subject, int options=0, PcreExtra extra=None, int offset=0):
    cdef:
        int rc
        int subject_length
        int oveccount
        int *ovector
        ExecResult exec_result = ExecResult.__new__(ExecResult)
        const_char *match_ptr
        int i, n
        int start, end
        bint subject_is_unicode = isinstance(subject, unicode)
        int last_index = 0, end_offset = -1, last_match_len = 0, match_len, py_match_len

    subject = process_text(subject)
    subject_length = len(subject)
    if extra is None:
        extra = PcreExtra.__new__(PcreExtra)

    # get the pcre info if we don't have it already
    if re.info_available == 0:
        pcre_info(re, extra)
    
    # mark handling
    if extra._c_pcre_extra is not NULL and extra._c_pcre_extra.flags & cpcre._PCRE_EXTRA_MARK:
        extra._c_pcre_extra.mark = &exec_result.markptr

    # replace the default with (the actual number of capturing subpatterns + 1) * 3
    oveccount = (re.groups + 1) * 3

    ovector = <int*>cpcre.pcre_malloc(oveccount * sizeof(int))
    if ovector is NULL:
        raise MemoryError()

    rc = cpcre.pcre_exec(re._c_pcre, extra._c_pcre_extra, subject, subject_length, offset, options & PCRE_EXEC_OPTIONS_MASK, ovector, oveccount)
    exec_result.result = rc
    exec_result.ovector = ovector
    exec_result.offset = offset
    if rc == 0:
        rc = oveccount / 3
        exec_result.captured_all = 0
    if rc > 0:
        exec_result.num_matches = rc
        for i in range(rc):
            match_len = cpcre.pcre_get_substring(subject, ovector, rc, i, &match_ptr)
            py_match_len = match_len
            if match_len < 0:
                raise PcreException('error getting the match #%d' % i)
            if ovector[i * 2] >= 0:
                match = match_ptr[:match_len]
                if subject_is_unicode:
                    match = tounicode_with_length(<char*>match_ptr, match_len)
                    py_match_len = len(match)
                exec_result.matches.append(match)
            else:
                exec_result.matches.append(None)
            start = ovector[i * 2]
            end = ovector[i * 2 + 1]
            if subject_is_unicode and start >= 0:
                str_before = tounicode_with_length(<char*>subject, ovector[i * 2])
                start = len(str_before)
                end = start + py_match_len
            exec_result.start_offsets.append(start)
            exec_result.end_offsets.append(end)
            cpcre.pcre_free_substring(match_ptr)
            # lastindex and lastgroup
            if i > 0:
                if end > end_offset:
                    end_offset = end
                    last_match_len = py_match_len
                    last_index = i
                elif end == end_offset:
                    if py_match_len > last_match_len:
                        last_match_len = py_match_len
                        last_index = i
        # lastindex and lastgroup
        if last_index:
            exec_result.lastindex = last_index
            for name, i in re.groupindex.iteritems():
                if i == last_index:
                    exec_result.lastgroup = name
                    break

        # if the unmatched groups are at the end, PCRE doesn't bother reporting them
        # so we have to do it ourselves
        for i in range(oveccount / 3 - rc):
            exec_result.matches.append(None)
            exec_result.start_offsets.append(-1)
            exec_result.end_offsets.append(-1)

        # named substrings
        for substring_name in re.groupindex:
            n = re.groupindex[substring_name]
            exec_result.named_matches[substring_name] = exec_result.matches[n]
    elif rc < 0:
        process_exec_error(rc)
    return exec_result

cpdef inline list pcre_find_all(Pcre re, subject, int options=0, PcreExtra extra=None, int offset=0, int count=0):
    """
    translated and adapted from pcredemo.c
    """
    orig_subject = subject
    subject = process_text(subject)
    cdef:
        ExecResult exec_result
        unsigned int option_bits
        int utf8
        int d
        bint crlf_is_newline
        char* c_subject = subject
        int subject_length = len(c_subject)
        int start_offset
        int end_offset
        list exec_results = []
        int counter = 0

    # Before running the loop, check for UTF-8 and whether CRLF is a valid newline
    # sequence. First, find the options with which the regex was compiled; extract
    # the UTF-8 state, and mask off all but the newline options.

    pcre_fullinfo_wrapper(re._c_pcre, NULL, cpcre._PCRE_INFO_OPTIONS, &option_bits);
    utf8 = option_bits & cpcre._PCRE_UTF8
    option_bits &= cpcre._PCRE_NEWLINE_CR|cpcre._PCRE_NEWLINE_LF | cpcre._PCRE_NEWLINE_CRLF | cpcre._PCRE_NEWLINE_ANY | cpcre._PCRE_NEWLINE_ANYCRLF

    # If no newline options were set, find the default newline convention from the
    # build configuration.
    if option_bits == 0:
        cpcre.pcre_config(cpcre._PCRE_CONFIG_NEWLINE, &d)
        # Note that these values are always the ASCII ones, even in
        # EBCDIC environments. CR = 13, NL = 10.
        option_bits = cpcre._PCRE_NEWLINE_CR if d == 13 else (
            cpcre._PCRE_NEWLINE_LF if d == 10 else (
                cpcre._PCRE_NEWLINE_CRLF if d == (13<<8 | 10) else (
                    cpcre._PCRE_NEWLINE_ANYCRLF if d == -2 else (
                        cpcre._PCRE_NEWLINE_ANY if d == -1 else 0
                    )
                )
            )
        )

    # See if CRLF is a valid newline sequence.
    crlf_is_newline = option_bits == cpcre._PCRE_NEWLINE_ANY or option_bits == cpcre._PCRE_NEWLINE_CRLF or option_bits == cpcre._PCRE_NEWLINE_ANYCRLF

    not_empty_options = 0
    end_offset = offset
    while True:
        start_offset = end_offset # Start at end of previous match
        # Run the matching operation
        exec_result = pcre_exec(re, orig_subject, (options | not_empty_options) & PCRE_EXEC_OPTIONS_MASK, extra, start_offset)

        exec_result.offset = start_offset
        end_offset = exec_result.ovector[1]

        # This time, a result of NOMATCH isn't an error. If the value in "not_empty_options"
        # is zero, it just means we have found all possible matches, so the loop ends.
        # Otherwise, it means we have failed to find a non-empty-string match at a
        # point where there was a previous empty-string match. In this case, we do what
        # Perl does: advance the matching position by one character, and continue. We
        # do this by setting the "end of previous match" offset, because that is picked
        # up at the top of the loop as the point at which to start again.

        # There are two complications: (a) When CRLF is a valid newline sequence, and
        # the current position is just before it, advance by an extra byte. (b)
        # Otherwise we must ensure that we skip an entire UTF-8 character if we are in
        # UTF-8 mode.
        
        if exec_result.result == cpcre._PCRE_ERROR_NOMATCH:
            if not_empty_options == 0:
                break                                   # All matches found
            end_offset = start_offset + 1               # Advance one byte
            not_empty_options = 0
                                                        # If CRLF is newline & we are at CRLF,
            if crlf_is_newline and \
               start_offset < subject_length - 1 and \
               c_subject[start_offset] == '\r' and \
               c_subject[start_offset + 1] == '\n':
                end_offset += 1                         # Advance by one more.
            elif utf8:                                  # Otherwise, ensure we advance a whole UTF-8
                while end_offset < subject_length:      # character.
                    if (c_subject[end_offset] & 0xc0) != 0x80:
                        break
                    end_offset += 1
            continue # Go round the loop again

        # Other matching errors are not recoverable.
        if exec_result.result < 0:
            break

        # Match succeded
        exec_results.append(exec_result)
        counter += 1
        if counter == count:
            break

        # If the previous match was for an empty string, we are finished if we are
        # at the end of the subject. Otherwise, arrange to run another match at the
        # same point to see if a non-empty match can be found.
        not_empty_options = 0
        if exec_result.ovector[0] == exec_result.ovector[1]:
            if exec_result.ovector[0] == subject_length:
                break
            not_empty_options = cpcre._PCRE_NOTEMPTY_ATSTART | cpcre._PCRE_ANCHORED
    return exec_results

cpdef inline pcre_split(Pcre re, string, int maxsplit=0, int options=0, PcreExtra extra=None):
    cdef:
        int last_index = 0
        int counter = 0
        ExecResult result
    
    string = process_text(string)
    res = []
    for result in pcre_find_all(re, string, options | cpcre._PCRE_NOTEMPTY, extra, count=maxsplit):
        res.append(string[last_index:result.start_offsets[0]])
        last_index = result.end_offsets[0]
        if len(result.matches) > 1:
            res.extend(result.matches[1:])
        counter += 1
        if counter == maxsplit:
            break
    res.append(string[last_index:])
    return res

# TODO: test this function
cpdef inline pcre_fsubn(Pcre re, repl, string, int count=0, int options=0, PcreExtra extra=None):
    cdef:
        int last_index = 0
        int counter = 0
        bint is_callable = 0
        ExecResult result
    
    orig_string = string
    string = process_text(string)
    pieces = []
    if hasattr(repl, '__call__'):
        is_callable = 1
    for result in pcre_find_all(re, string, options, extra, count=count):
        counter += 1
        pieces.append(string[last_index:result.start_offsets[0]])
        last_index = result.end_offsets[0]
        if is_callable:
            replacement = repl(result)
        else:
            replacement = repl.format(*result.matches, **result.named_matches)
        pieces.append(replacement)
        if count == counter:
            break
    pieces.append(orig_string[last_index:])
    return orig_string[:0].join(pieces), counter

cpdef inline pcre_fsub(Pcre re, repl, string, int count=0, int options=0, PcreExtra extra=None):
    return pcre_fsubn(re, repl, string, count, options, extra)[0]

cpdef inline pcre_subn(Pcre re, repl, string, int count=0, int options=0, PcreExtra extra=None):
    cdef:
        int last_index = 0
        int counter = 0
        bint is_callable = 0
        ExecResult result
        int start_offset
    
    orig_string = string
    string = process_text(string)
    pieces = []
    if hasattr(repl, '__call__'):
        is_callable = 1
    last_match = ''
    for result in pcre_find_all(re, string, options, extra, count=count):
        start_offset = result.start_offsets[0]
        if last_match != '' and result.matches[0] == '' and last_index == start_offset:
            continue
        last_match = result.matches[0]
        counter += 1
        if start_offset > last_index:
            pieces.append(string[last_index:start_offset])
        last_index = result.end_offsets[0]
        if is_callable:
            replacement = repl(result)
        else:
            replacement = pcre_expand(re, result.matches, repl, string)
        pieces.append(replacement)
        if count == counter:
            break
    if len(string) > last_index:
        pieces.append(string[last_index:])
    if len(pieces) == 1 and isinstance(orig_string, str):
        return pieces[0], counter # 're' bug 1140 compatibility
    return orig_string[:0].join(pieces), counter

cpdef inline pcre_sub(Pcre re, repl, string, int count=0, int options=0, PcreExtra extra=None):
    return pcre_subn(re, repl, string, count, options, extra)[0]

cdef class SRE_Match(object):
    cdef object __weakref__
    cdef public:
        ExecResult pcre_exec_result
        SRE_Pattern re
        object string
        int pos
        object endpos
        object lastindex
        object lastgroup
        tuple _regs

    def __cinit__(self):
        self._regs = None

    def __init__(self, exec_result, re, string, pos=0, endpos=None):
        self.pcre_exec_result = exec_result
        self.re = re
        self.string = string
        self.pos = pos
        self.endpos = endpos
        self.lastindex = exec_result.lastindex
        self.lastgroup = exec_result.lastgroup

    @property
    def regs(self):
        if self._regs is None:
            if self.pcre_exec_result.num_matches:
                self._regs = tuple(zip(self.pcre_exec_result.start_offsets, self.pcre_exec_result.end_offsets))
        return self._regs

    cpdef expand(self, template):
        return pcre_expand(self.re.pcre_compiled, self.pcre_exec_result.matches, template, self.string)

    def group(self, *args):
        pargs = [] # processed args
        for arg in args:
            if isinstance(arg, basestring):
                try:
                    pargs.append(self.re.groupindex[arg])
                except:
                    raise IndexError('no such group')
            else:
                pargs.append(arg)
        try:
            if len(pargs) == 0:
                res = self.pcre_exec_result.matches[0]
            elif len(pargs) == 1:
                res = self.pcre_exec_result.matches[pargs[0]]
            else:
                res = tuple([self.pcre_exec_result.matches[arg] for arg in pargs])
        except:
            raise IndexError('no such group')
        return res

    cpdef groups(self, default=None):
        return tuple([default if m is None else m for m in self.pcre_exec_result.matches[1:]])

    cpdef groupdict(self, default=None):
        return dict([(n, default if m is None else m) for n, m in self.pcre_exec_result.named_matches.items()])

    cpdef start(self, group=0):
        try:
            return self.pcre_exec_result.start_offsets[group]
        except:
            raise IndexError('no such group')

    cpdef end(self, group=0):
        try:
            return self.pcre_exec_result.end_offsets[group]
        except:
            raise IndexError('no such group')

    cpdef span(self, group=0):
        return (self.start(group), self.end(group))

cdef class SRE_Iterator:
    cdef:
        object orig_string
        SRE_Pattern re
        int pos
        int endpos
        list results
        int index

    def __init__(self, string, orig_string, pos, endpos, re):
        self.orig_string = orig_string
        self.re = re
        self.pos = pos
        self.endpos = endpos
        self.results = pcre_find_all(re.pcre_compiled, string, re.used_flags, re.pcre_extra, pos)
        self.index = -1

    def __iter__(self):
        return self

    def __next__(self):
        try:
            self.index += 1
            return SRE_Match(self.results[self.index], self.re, self.orig_string, self.pos, self.endpos)
        except IndexError:
            raise StopIteration

cdef class SRE_Pattern(object):
    cdef:
        object __weakref__
        object _subn_repl
        object _subn_string
    cdef public:
        object pattern
        unsigned int flags
        unsigned int used_flags
        Pcre pcre_compiled
        PcreExtra pcre_extra
        int groups
        dict groupindex

    def __init__(self, pattern, flags):
        self.pattern = pattern
        self.flags = flags
        self.used_flags = flags | cpcre._PCRE_NO_UTF8_CHECK
        # don't support some escapes that are invalid in 're' (just \ddd so we don't mess with the back references)
        cdef ExecResult res = pcre_exec(pcre_compile(r'(?:^|[^\\])(\\[89][0-9][0-9])'), pattern)
        if res.num_matches:
            raise PcreException('bogus escape: %r' % res.matches[1])
        # handle internal options with a different syntax from PCRE
        pat = pcre_fsub(pcre_compile(r'(\(\?[imsux]*)L([imsux]*\))'), r'{1}{2}', pattern)
        pat = pcre_fsub(pcre_compile(r'(\(\?[imsx]*)u([imsx]*\))'), r'(*UTF)(*UCP){1}{2}', pat)
        # process the pattern
        self.pcre_compiled = pcre_compile(pat, self.used_flags)
        # TODO: have a separate set of study flags (the JIT ones overlap some exec/compile flags)
        #self.pcre_extra = pcre_study(self.pcre_compiled, self.used_flags)
        self.pcre_extra = pcre_study(self.pcre_compiled)
        pcre_info(self.pcre_compiled, self.pcre_extra)
        self.groups = self.pcre_compiled.groups
        self.groupindex = self.pcre_compiled.groupindex

    cpdef search(self, string, pos=0, endpos=None):
        cdef:
            ExecResult exec_result

        if not isinstance(string, basestring):
            string = unicode(string)
        orig_string = string
        if endpos is not None:
            if endpos < pos:
                return None
            string = string[:endpos]
        else:
            endpos = len(string)
        exec_result = pcre_exec(self.pcre_compiled, string, self.used_flags, self.pcre_extra, pos)
        if exec_result.num_matches == 0:
            return None
        return SRE_Match(exec_result, self, orig_string, pos, endpos)

    cpdef match(self, string, pos=0, endpos=None):
        if not isinstance(string, basestring):
            string = unicode(string)
        already_anchored = self.used_flags & cpcre._PCRE_ANCHORED
        if not already_anchored:
            self.used_flags |= cpcre._PCRE_ANCHORED
        res = self.search(string, pos, endpos)
        if not already_anchored:
            self.used_flags &= ~cpcre._PCRE_ANCHORED
        return res

    cpdef split(self, string, maxsplit=0):
        if not isinstance(string, basestring):
            raise TypeError('expected string or buffer')
        return pcre_split(self.pcre_compiled, string, maxsplit, self.used_flags, self.pcre_extra)

    cpdef findall(self, string, pos=0, endpos=None):
        cdef ExecResult result
        if not isinstance(string, basestring):
            raise TypeError('expected string or buffer')
        if endpos is not None:
            if endpos < pos:
                return None
            string = string[:endpos]
        res = []
        for result in pcre_find_all(self.pcre_compiled, string, self.used_flags, self.pcre_extra, pos):
            matches = ['' if match is None else match for match in result.matches]
            if len(matches) == 1:
                res.append(matches[0])
            elif len(matches) == 2:
                res.append(matches[1])
            else:
                res.append(tuple(matches[1:]))
        return res

    def finditer(self, string, pos=0, endpos=None):
        if not isinstance(string, basestring):
            raise TypeError('expected string or buffer')
        orig_string = string
        if endpos is not None:
            if endpos < pos:
                return None
            string = string[:endpos]
        else:
            endpos = len(string)
        return SRE_Iterator(string, orig_string, pos, endpos, self)

    cpdef _repl_wrapper(self, result):
        return self._subn_repl(SRE_Match(result, self, self._subn_string))

    cpdef subn(self, repl, string, count=0):
        used_repl = repl
        if hasattr(repl, '__call__'):
            self._subn_repl = repl
            self._subn_string = string
            used_repl = self._repl_wrapper
        return pcre_subn(self.pcre_compiled, used_repl, string, count, self.used_flags, extra=self.pcre_extra)

    cpdef sub(self, repl, string, count=0):
        return self.subn(repl, string, count)[0]

    def scanner(self, *args):
        """
        undocumented but appears in tests and might be used in the wild
        so let's have it but don't bother converting it to PCRE
        """
        import re
        return re.compile(self.pattern, self.flags).scanner(*args)

### template expansion code from the original 're' module:

MARK = "mark"
DIGITS = set("0123456789")
OCTDIGITS = set("01234567")
LITERAL = "literal"
ESCAPES = {
    r"\a": (LITERAL, ord("\a")),
    r"\b": (LITERAL, ord("\b")),
    r"\f": (LITERAL, ord("\f")),
    r"\n": (LITERAL, ord("\n")),
    r"\r": (LITERAL, ord("\r")),
    r"\t": (LITERAL, ord("\t")),
    r"\v": (LITERAL, ord("\v")),
    r"\\": (LITERAL, ord("\\"))
}

cdef class SRE_Tokenizer:
    cdef:
        object string, next
        int index

    def __init__(self, string):
        self.string = string
        self.index = 0
        self.__next()

    cdef __next(self):
        if self.index >= len(self.string):
            self.next = None
            return
        char = self.string[self.index]
        if char[0] == "\\":
            try:
                c = self.string[self.index + 1]
            except IndexError:
                raise PcreException, "bogus escape (end of line)"
            char = char + c
        self.index = self.index + len(char)
        self.next = char

    cdef match(self, _char, bint skip=1):
        if _char == self.next:
            if skip:
                self.__next()
            return 1
        return 0

    cdef get(self):
        this = self.next
        self.__next()
        return this

    cdef tell(self):
        return self.index, self.next

    cdef seek(self, int index):
        self.index, self.next = index

@cython.profile(False)
cdef inline isident(char* _char):
    return b"a" <= _char <= b"z" or b"A" <= _char <= b"Z" or _char == b"_"

@cython.profile(False)
cdef inline bint isdigit(char* _char):
    return b"0" <= _char <= b"9"

@cython.profile(False)
cdef inline bint isname(name):
    # check that group name is a valid string
    if not isident(name[0]):
        return False
    for _char in name[1:]:
        if not isident(_char) and not isdigit(_char):
            return False
    return True

@cython.profile(False)
cdef inline literal(literal, p):
    if p and p[-1][0] is LITERAL:
        p[-1] = LITERAL, p[-1][1] + literal
    else:
        p.append((LITERAL, literal))

cdef inline parse_template(source, pattern):
    # parse 're' replacement string into list of literals and
    # group references
    cdef:
        SRE_Tokenizer s = SRE_Tokenizer(source)
        int i
        list p = [], groups, literals
    sep = source[:0]
    if type(sep) is type(""):
        makechar = chr
    else:
        makechar = unichr
    while 1:
        this = s.get()
        if this is None:
            break # end of replacement string
        if this and this[0] == "\\":
            # group
            c = this[1:2]
            if c == "g":
                name = ""
                if s.match("<"):
                    while 1:
                        char = s.get()
                        if char is None:
                            raise PcreException, "unterminated group name"
                        if char == ">":
                            break
                        name = name + char
                if not name:
                    raise PcreException, "bad group name"
                try:
                    index = int(name)
                    if index < 0:
                        raise PcreException, "negative group number"
                except ValueError:
                    if not isname(name):
                        raise PcreException, "bad character in group name"
                    try:
                        index = pattern.groupindex[name]
                    except KeyError:
                        raise IndexError, "unknown group name"
                p.append((MARK, index))
            elif c == "0":
                if s.next in OCTDIGITS:
                    this = this + s.get()
                    if s.next in OCTDIGITS:
                        this = this + s.get()
                literal(makechar(int(this[1:], 8) & 0xff), p)
            elif c in DIGITS:
                isoctal = False
                if s.next in DIGITS:
                    this = this + s.get()
                    if (c in OCTDIGITS and this[2] in OCTDIGITS and
                        s.next in OCTDIGITS):
                        this = this + s.get()
                        isoctal = True
                        literal(makechar(int(this[1:], 8) & 0xff), p)
                if not isoctal:
                    p.append((MARK, int(this[1:])))
            else:
                try:
                    this = makechar(ESCAPES[this][1])
                except KeyError:
                    pass
                literal(this, p)
        else:
            literal(this, p)
    # convert template to groups and literals lists
    i = 0
    groups = []
    literals = [None] * len(p)
    for c, ss in p:
        if c is MARK:
            groups.append((i, ss))
            # literal[i] is already None
        else:
            literals[i] = ss
        i = i + 1
    return groups, literals

cdef inline expand_template(template, matches, string):
    cdef:
        int index, group
        list groups, literals

    groups, literals = template
    literals = literals[:]
    try:
        for index, group in groups:
            literals[index] = s = matches[group]
            if s is None:
                raise PcreException, "unmatched group"
    except IndexError:
        raise PcreException, "invalid group reference"
    return string[:0].join(literals)

cpdef inline pcre_expand(Pcre pattern, matches, template, string):
    template = parse_template(template, pattern)
    return expand_template(template, matches, string)

